#define SAMPLE_ALICE_KP                                                                                                \
    "3FBB6FDBC02DDC8680BBACC03D03A4A173D35CDA385E879B9C17C904F4F63C2A1DE418C8754CEE06C96C7C4175CEB4FA4BD99E513A9B88A1" \
    "EFA6C343782E0C62E8BD6C37A90DCDBB5E0756BEBB2759DEE3F131DB5A1087A06DAD11A3B11E44926D38C935DC47BD4E411FE8B64D5AE4E8" \
    "D3DEA2D8E79C210B9C053C2DF23CCDDD63B2B2F947761EDADF4B4C351637571FB8853AF2F4D501A763123011237320A7C9A32A2F78079C45" \
    "7FD8D0641E9E82634A2BD10713CDFDC402AFA245617E745D16A9FA221D58613192E754778CD05E09D1134B256E54759060DB1F21286C1281" \
    "19EA0B125B0BA863C4DBFB519EE6DF7E372E02BF1B1D581F91B217F1E99FB069\nDD044E59725311A1DA1CD39376216D94A9D4FFE67DDD40" \
    "63D9925965FA2B65C71FE69924F1B0CD3BD486967C3369CF09C946A6389DFB30BB067932F88965AF2C1C23465DD31D4EDB94A3CF175E79AB" \
    "8DE62600808CD19A6B99EAF8115A69B7B4C720E6D0316E68FC76ECA62D6234132E76CA4C3346E37AC0BB8234D02546830D9123616E2BB00E" \
    "B1EAECB2C9DF3FF785DA23A986A9236A7A69B6ACFF8543247F2419B565BF6663D3BB3913A5749B4E0BEE9ABB41EE5A3E13CB4C5FBFE48234" \
    "089DBBEBC900BE27AB1664C8A3D0F42253EB0CE09CB2AE148D182F0D30EA7F298D5623A1635D3491E43FE49F5BF36D9A62E4618C8D6F7481" \
    "33AA065092F8AD52DD\nDC81D3AC5808EC93526568A2BCC7CBD9\nDD044E59725311A1DA1CD39376216D94A9D4FFE67DDD4063D9925965FA" \
    "2B65C71FE69924F1B0CD3BD486967C3369CF09C946A6389DFB30BB067932F88965AF2C1C23465DD31D4EDB94A3CF175E79AB8DE62600808C" \
    "D19A6B99EAF8115A69B7B4C720E6D0316E68FC76ECA62D6234132E76CA4C3346E37AC0BB8234D02546830D9123616E2BB00EB1EAECB2C9DF" \
    "3FF785DA23A986A9236A7A69B6ACFF8543247F2419B565BF6663D3BB3913A5749B4E0BEE9ABB41EE5A3E13CB4C5FBFE48234089DBBEBC900" \
    "BE27AB1664C8A3D0F42253EB0CE09CB2AE148D182F0D30EA7F298D5623A1635D3491E43FE49F5BF36D9A62E4618C8D6F748133AA065092F8" \
    "AD52DD\n"
#define SAMPLE_BOB_PK                                                                                                  \
    "2E76A0094D4CEE0AC516CA162973C895\n1985008F25A025097712D26B5A322982B6EBAFA5826B6EDA3B91F78B7BD63981382581218D33A9" \
    "983E4E14D4B26113AA2A83BBCCFDE24310AEE3362B6100D06CC1EA429018A0FF3614C077F59DE55AADF449AF01E42ED6545127DC1A97954B" \
    "89729249C6060BA4BD3A59490839072929C0304B2D7CBBA368AEBC4878A6F0DA3FE58CECDA638A506C723BDCBAB8C355F83C0839BF1457A3" \
    "B6B89307D672BBF530C93F022E693116FE4A5703A665C6010B5192F6D1FAB64B5795876B2164C86ABD7650AEDAF5B6AFCAC0438437BB3BDF" \
    "5399D80F8D9963B5414EAFBFA1AA2DD0D24988ACECA8D50047E5A78082295A987369A67D3E54FFB7996CBE2C5EAD794391\n"
#define SAMPLE_SIG                                                                                                     \
    "D6ED5F0E22E367665A5F77354B4D8CE9\n03446C8281A9C000C470B9739E7A96E6B87851202E294C4EC1C102D5DC3AFE837D3E5C8A191E95" \
    "B54B88BC9C0E466197EBA00D0CD6A92B5C09ED1EEB77ABE46FEFFBA7FD84E0E9E4909768393B8A58BB5080F1DB79D6D55C944B7C60FF5CA8" \
    "2839DBC6996A5AE64A3F22D2058F1AF126F80BE0734D916E170A9635CD8E7513365F3E13F333BF63ED8907444A2343B1B1216D049433E7DD" \
    "82A5564E21FD92DBD4D01D816B5151E3293DD3AB5442004E1675639C7290ACF8E7C3FB5C299816ED021CBCABE7E412C1B9B086C68C0875DA" \
    "BC240D5AEBC6A4B6E2BE6F6C1658ADECC255AF6FEB0FA407C9464A1AA8199E846B43C45154B04F6B8F8730912081600D96\nC735C617B155" \
    "1493AE7B00462DA721305CFEBC5A89382FA58859F773A9994A15EB4F9058A2A9D822301DF5D5D522FCEA4A9B96332F1887AB4B43E0F49305" \
    "6F24F1557BD1B0376C0DECEBD1F175FFE6D1839840512A53834B8690F6BE90B4786DC76D46C9114F87B8963BDECDAA015FE0AD31B3C1A8C2" \
    "167D079757D8CCA31032B38081C3C239808E3FC204EE9FE8F712374D92C0D5C773759A4CEBE1D965816EEB57718B67F59A7498D1140DBC96" \
    "CCF423601B45C82AD84676C57027E6B596B095B8BF89B8FFDAB4CFEDFE4D445C68BEDC985AB70693C43F1F8580F9E5D21AE4CECC42614DDE" \
    "AD5A798391EF90B1E999CEC77BC86651F33127A654ABCD92D2D9\nDC81D3AC5808EC93526568A2BCC7CBD9\nDD044E59725311A1DA1CD393" \
    "76216D94A9D4FFE67DDD4063D9925965FA2B65C71FE69924F1B0CD3BD486967C3369CF09C946A6389DFB30BB067932F88965AF2C1C23465D" \
    "D31D4EDB94A3CF175E79AB8DE62600808CD19A6B99EAF8115A69B7B4C720E6D0316E68FC76ECA62D6234132E76CA4C3346E37AC0BB8234D0" \
    "2546830D9123616E2BB00EB1EAECB2C9DF3FF785DA23A986A9236A7A69B6ACFF8543247F2419B565BF6663D3BB3913A5749B4E0BEE9ABB41" \
    "EE5A3E13CB4C5FBFE48234089DBBEBC900BE27AB1664C8A3D0F42253EB0CE09CB2AE148D182F0D30EA7F298D5623A1635D3491E43FE49F5B" \
    "F36D9A62E4618C8D6F748133AA065092F8AD52DD\n"
#define SAMPLE_MESSAGE                                                                                                 \
    "14B9F8EDD5BC19444D8A7367D6B43E32DF6B73894335545EFD66C3244AFF31539F2E6C452E2E4368875287EB7A4FC5A5CDEDBA87ECB7A18F" \
    "86AD494BDC5B1B7BE8CF395C1543651F959BBA28B2698B552BE05B7351BA41B3185E08EAD4D31655D05A77720C04082985EDC6658C1B9AFD" \
    "20B66C1A54278E4FD33427AC6E1C7A2C69C9CBE424B122AE578332CA04C422596237B76BBC3D7055584F2350349F091E7F54ECF04095BB6B" \
    "770A37CA6B852EF1C8DB6F9CCEFEEF0090C4C0215E9FDAE28D0420ABF833319203A784CB580826D64E39BDF61015B55FF1234D874DACE360" \
    "AA7840DAA51DE314F141FF2F2A0DADE79CF3B77F12B7B55DC6AF50CE08B7B2B9\n1DA6526BC9A90E51CD0DDA4262D71021BBFDE1A900FF4D" \
    "1ABD044F0098033BCE498A533ACE9E19E77A6762C095F295F8002C90D4A4364030C17B38C6A16289353A83B3317BA8A5973DEAA7248D38CA" \
    "AA\n"
#define SAMPLE_MESSAGE_INV                                                                                             \
    "2DF52A5BC59F851762E7AC00019D0C4F5F19FC2C6E724AB38FD86BF9A79AD018D9F06E6F5C8CC4D78AEADA8E93D3BB001D58DB697829B284" \
    "562165169006148CD8B822735CC2CEAF2CBF08434F8DAA022A8976D964312E5F3C3FA9542C11843A\n18E3E9FF5B3D26C908BA7D63DC74E2" \
    "02C6A3A9E30E45DE87E179D155AF02B103FC8C278DC1B1EF9925CB725D4851222E85A1DEF84B1950D87390FE2DAF71EC345AFDA1D603C611" \
    "96FE5B8BC3FBABE1D9D9E6041D7B0E0CA68BD7145FF382D91F1E72912383D01E99D0C6B45AE6A04DE41A25D18769A54A7D4A0916A36A9712" \
    "CEF52F6417D6F1C2334A84E0A8D70D9496CE328DA6E63B340E86D220C797653E2156E37FB0397809C3F3261B840EEB71A4A8CAC31A6AD4C5" \
    "43254C2359FFA6CA045EEBF491292B2CA95CC828F5FF204CA3058BBD1E61EB7F3EC079EABBDAC504D8C644C03D4545F141ADB60D85E064AD" \
    "FE95E0B16189F7A82E714DAE479C1856EE\n"
#define SAMPLE_MESSAGE_2                                                                                               \
    "10F2D1C49CE9B565C06D9794E911ABE2A14056D092DD138E045AB8AB944B5F901B700D3A282636F1BAA72D0E1A95EE7D702A2932FF81C996" \
    "85DA8B25099C852A000CB3F33670C1EDD280B2A5BBECA84B36F42B41255F2FB41B79182A65E40685539FD48C5352478A27F41C8365E45D0F" \
    "49B73FD003F36DB7B4B97D007978D950F4F0DA63A0F4A699C0BA63A16A644C124157391E8D5705DFFAA194E45AD20C3603187895D1F2C1D7" \
    "2491A5619CE8976279A31EBC4D03DEF2F98A55308C09D5E2A1E97BE0BFBF57469028D7E5ACDAC21E9D6709407F4428CF90380ED6BE9ECE4B" \
    "79B8BD098818F94594D385E00A26D5056ABDA832F094F25EEE9EAD62575DF5CB\n8C854BF81B2B0074524E9EC8175F3D7E3D9D2E22B444EA" \
    "F969003F8DC92E0B7016CAF870EA3EA3C138F8A51BF53442E4D31C345F3E7423262E3DDC3E9F2331CFA387EEABE35E105AE8269D9942711A" \
    "454EE6D1EA46D24714DE7DAD1C1C3CA446C7C2A687BD39AA7C8CDCA04E6EC64849E91BA46F0FC3D1464582E2A826F16F75\n"

#include "cipher.h"
#include "rsa.h"
#include "types.h"
#include "util.h"
#include <openssl/rand.h>
#include <stdio.h>
#include <stdlib.h>

void help(char const *const name);

void gen(void);
void sign(void);
bool verify(char const *const filename);

int main(int argc, char **argv) {
    if (argc < 2) {
        help(argv[0]);
        exit(1);
    }

    char const *const mode = argv[1];

    // Setup OpenSSL random generator
    RAND_poll();

    // Basic modes
    if (strcmp(mode, "gen") == 0) {
        gen();
        exit(0);
    } else if (strcmp(mode, "sign") == 0) {
        sign();
        exit(0);
    } else if (strcmp(mode, "help") == 0) {
        help(argv[0]);
        exit(0);
    } else if (strcmp(mode, "samples") == 0) {
        write_string_to_file(ALICE_KP_FILE, SAMPLE_ALICE_KP);
        write_string_to_file(BOB_PK_N_FILE, SAMPLE_BOB_PK);
        write_string_to_file(SIG_FILE, SAMPLE_SIG);
        write_string_to_file("message.txt", SAMPLE_MESSAGE);
        write_string_to_file("message_inv.txt", SAMPLE_MESSAGE_INV);
        write_string_to_file("message_2.txt", SAMPLE_MESSAGE_2);

        printf("Example files written\n");
        exit(0);
    }

    // File-related modes
    // Every subsequent mode verifies the message and signature, so we're using
    // early returns and cascades (e.g. decrypt is actually verify and then decrypt)
    if (argc < 3) {
        fprintf(stderr, "No file specified\n");
        help(argv[0]);
        exit(1);
    }

    if (verify(argv[2])) {
        printf("Signature is valid\n");
    } else {
        fprintf(stderr, "Signature is invalid\n");
        exit(1);
    }

    if (strcmp(mode, "verify") == 0) {
        exit(0);
    }

    // Decryption is used by both encrypt_inv and decrypt.
    // The encrypt mode doesn't use the decrypted message, so we branch here.

    int alice_message_len;
    unsigned char *alice_message;

    if (strcmp(mode, "encrypt") == 0) {
        if (argc < 4) {
            fprintf(stderr, "No message specified\n");
            help(argv[0]);
            exit(1);
        }

        alice_message_len = asprintf((char **)&alice_message, "%s", argv[3]);
        printf("Message to encrypt: %s\n", alice_message);
    } else if (strcmp(mode, "encrypt_inv") == 0 || strcmp(mode, "decrypt") == 0) {
        int message_len;
        unsigned char *message = decrypt_file(argv[2], &message_len);
        printf("Message: %s\n", message);

        // Save the decrypted message to a file
        char *decrypt_filename;
        (void)!asprintf(&decrypt_filename, "%s.decrypt", argv[2]);

        // Since we can't be sure that the data is null-terminated, don't use
        // string functions
        write_to_file(decrypt_filename, message, message_len, "w");
        free(decrypt_filename);

        if (strcmp(mode, "decrypt") == 0) {
            free(message);
            exit(0);
        }

        // I'm aware that this is a bit of a waste of memory (i.e. we could've
        // used alice_message_len from the start), but it's easier to read and
        // understand the code this way.
        alice_message_len = message_len;

        // Invert the message
        alice_message = invert_array(message, message_len);
        printf("Inverted message: %s\n", alice_message);
        free(message);
    } else {
        fprintf(stderr, "Invalid mode\n");
        help(argv[0]);
        exit(1);
    }

    MessageStream *msg_alice = encrypt_and_sign(alice_message, alice_message_len);

    char *out_filename;
    (void)!asprintf(&out_filename, "%s.alice", argv[2]);
    MS_save_to_file(msg_alice, out_filename);
    free(out_filename);

    free(alice_message);
    MS_destroy(msg_alice);

    return 0;
}

void gen(void) {
    if (access(ALICE_KP_FILE, F_OK) == F_OK) {
        fprintf(stderr, "Error: Alice's key pair already exists\n");
        exit(1);
    }

    RSAKeyPair *alice_kp = RSAKP_generate();
    RSAKP_to_file(alice_kp, ALICE_KP_FILE);
    printf("Saved Alice's keypair to file %s\n", ALICE_KP_FILE);

    RSAKP_free(alice_kp);
}

void sign(void) {
    printf("Loading Alice's key pair from file %s\n", ALICE_KP_FILE);
    RSAKeyPair *alice_kp = RSAKP_load_from_file(ALICE_KP_FILE);

    printf("Loading Bob's public key from file %s\n", BOB_PK_N_FILE);
    RSAPublicKey *bob_pk = RSAPKey_load_from_file(BOB_PK_N_FILE);

    if (access(SIG_FILE, F_OK) == F_OK) {
        fprintf(stderr, "Error: Signature information already exists\n");
        exit(1);
    }

    BIGNUM *aes_key = BN_new();
    BN_rand(aes_key, 128, 0, 0);

    BN_CTX *ctx = BN_CTX_new();
    BN_CTX_start(ctx);

    BIGNUM *x = BN_new(); // x = AES_key^eb mod nb
    BN_mod_exp(x, aes_key, bob_pk->e, bob_pk->n, ctx);

    BIGNUM *sig = BN_new(); // sig = x^da mod na
    BN_mod_exp(sig, x, alice_kp->sk->d, alice_kp->sk->n, ctx);

    FILE *file = open_file(SIG_FILE, "w");

    BN_to_file(aes_key, file);
    BN_to_file(x, file);
    BN_to_file(sig, file);
    BN_to_file(alice_kp->pk->e, file);
    BN_to_file(alice_kp->pk->n, file);

    fclose(file);

    BN_free(sig);
    BN_free(x);
    BN_free(aes_key);
    BN_free(bob_pk->e);
    BN_free(bob_pk->n);
    free(bob_pk);
    RSAKP_free(alice_kp);
    BN_CTX_end(ctx);
    BN_CTX_free(ctx);
}

bool verify(char const *const filename) {
    printf("Loading Bob's public key from file %s\n", BOB_PK_N_FILE);
    RSAPublicKey *const bob_pk = RSAPKey_load_from_file(BOB_PK_N_FILE);

    MessageStream *msg_bob = MS_load_from_file(filename);

    BN_CTX *bn_ctx = BN_CTX_new();
    BN_CTX_start(bn_ctx);

    bool verified = RSA_verify_signature(msg_bob, bob_pk, bn_ctx);

    // Cleanup

    MS_destroy(msg_bob);

    RSAPKey_free(bob_pk);
    BN_CTX_end(bn_ctx);
    BN_CTX_free(bn_ctx);

    return verified;
}

void help(char const *const name) {
    fprintf(stderr, "Usage: %s [command]\n", name);
    fprintf(stderr, "\nBasic commands:\n");
    fprintf(stderr, "\thelp      Display this help message and exit\n");
    fprintf(stderr, "\tsamples   Write sample files to disk and exit\n");
    fprintf(stderr, "\tgen       Generate a key pair and write it to " ALICE_KP_FILE "\n");
    fprintf(stderr, "\tsign      Generate a symmetric key using AES-128, enciphers the key, signs it and write "
                    "everything to " SIG_FILE "\n");

    fprintf(stderr, "\nFile-related commands:\n");
    fprintf(stderr, "\tverify <file>               Verify <file>'s signature using Bob's key from " BOB_PK_N_FILE "\n");
    fprintf(stderr, "\tdecrypt <file>              Decrypt <file> and print to stdout\n");
    fprintf(stderr, "\tencrypt_inv <file>          Decrypt <file> and create a new encrypted and signed message "
                    "inverting <file>'s contents\n");
    fprintf(
        stderr,
        "\tencrypt <file> <message>    Decrypt <file>, verify its signature, and write <message> to <file>.alice\n");

    fprintf(stderr, "\nFile structure:\n");
    fprintf(stderr, "\t" SIG_FILE " is the signature file, it is structured as follows (one per line):\n");
    fprintf(stderr, "\t\tAES_key\n");
    fprintf(stderr, "\t\tAES_key^e_b mod n_b, A.K.A. x\n");
    fprintf(stderr, "\t\tsig = x^d_a mod n_a\n");
    fprintf(stderr, "\t\tAlice's public key e_a\n");
    fprintf(stderr, "\t\tAlice's public key n_a\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "\t" ALICE_KP_FILE " is Alice's key pair file, it is structured as follows (one per line):\n");
    fprintf(stderr, "\t\tAlice's secret key d\n");
    fprintf(stderr, "\t\tAlice's secret key n\n");
    fprintf(stderr, "\t\tAlice's public key e\n");
    fprintf(stderr, "\t\tAlice's public key n (same as secret key n)\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "\t" BOB_PK_N_FILE " is Bob's public key file, it is structured as follows (one per line):\n");
    fprintf(stderr, "\t\tBob's public key e\n");
    fprintf(stderr, "\t\tBob's public key n\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "\t<file> is an encrypted and signed message file, and it is structured as follows:\n");
    fprintf(stderr, "\t\tSignature\n");
    fprintf(stderr, "\t\tIV (16 bytes) + Message\n");
    fprintf(stderr, "\n");
}
